{:rename-macros {}, :renames {}, :use-macros {}, :excludes #{}, :name leipzig.melody, :imports nil, :requires {scale leipzig.scale, leipzig.scale leipzig.scale}, :uses nil, :defs {mapthen {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 122, :column 7, :end-line 122, :end-column 14, :arglists (quote ([f & melodies])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f melodies)], :arglists ([f & melodies]), :arglists-meta (nil)}}, :name leipzig.melody/mapthen, :variadic true, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f melodies)], :arglists ([f & melodies]), :arglists-meta (nil)}, :method-params [(f melodies)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 122, :end-line 122, :max-fixed-arity 1, :fn-var true, :arglists ([f & melodies])}, tempo {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 137, :column 7, :end-line 137, :end-column 12, :arglists (quote ([timing notes])), :doc "Transform both :time and :duration according to timing.\n  e.g. (->> notes (tempo (bpm 120)))"}, :name leipzig.melody/tempo, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 12, :method-params ([timing notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 137, :end-line 137, :max-fixed-arity 2, :fn-var true, :arglists (quote ([timing notes])), :doc "Transform both :time and :duration according to timing.\n  e.g. (->> notes (tempo (bpm 120)))"}, bpm {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 4, :column 7, :end-line 4, :end-column 10, :arglists (quote ([beats])), :doc "Returns a function that translates a beat number into seconds.\n  e.g. ((bpm 90) 5)"}, :name leipzig.melody/bpm, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 10, :method-params ([beats]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4, :end-line 4, :max-fixed-arity 1, :fn-var true, :arglists (quote ([beats])), :doc "Returns a function that translates a beat number into seconds.\n  e.g. ((bpm 90) 5)"}, but {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 90, :column 7, :end-line 90, :end-column 10, :arglists (quote ([start end variation notes])), :doc "Replaces part of a melody with another.\n  e.g. (->> notes (but 2 4 variation))"}, :name leipzig.melody/but, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 10, :method-params ([start end variation notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 90, :end-line 90, :max-fixed-arity 4, :fn-var true, :arglists (quote ([start end variation notes])), :doc "Replaces part of a melody with another.\n  e.g. (->> notes (but 2 4 variation))"}, having {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 9, :column 7, :end-line 9, :end-column 13, :arglists (quote ([k values notes])), :doc "Zips an arbitrary quality onto a melody.\n  e.g. (->> (rhythm [1 1/2]) (having :drum [:kick :snare]))"}, :name leipzig.melody/having, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 13, :method-params ([k values notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9, :end-line 9, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k values notes])), :doc "Zips an arbitrary quality onto a melody.\n  e.g. (->> (rhythm [1 1/2]) (having :drum [:kick :snare]))"}, where {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 61, :column 7, :end-line 61, :end-column 12, :arglists (quote ([k f notes])), :doc "Applies f to the k key of each note in notes, ignoring missing keys.\n  e.g. (->> notes (where :time (bpm 90)))"}, :name leipzig.melody/where, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 12, :method-params ([k f notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 61, :end-line 61, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k f notes])), :doc "Applies f to the k key of each note in notes, ignoring missing keys.\n  e.g. (->> notes (where :time (bpm 90)))"}, is {:name leipzig.melody/is, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 47, :column 1, :end-line 47, :end-column 8, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 47, :column 6, :end-line 47, :end-column 8}, :doc "Synonym for constantly.\n  e.g. (->> notes (wherever (comp not :part), :part (is :bass)))"}, times {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 129, :column 7, :end-line 129, :end-column 12, :arglists (quote ([n notes])), :doc "Repeats notes n times.\n  e.g. (->> bassline (times 4))"}, :name leipzig.melody/times, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 12, :method-params ([n notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 129, :end-line 129, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n notes])), :doc "Repeats notes n times.\n  e.g. (->> bassline (times 4))"}, duration {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 105, :column 7, :end-line 105, :end-column 15, :arglists (quote ([notes])), :doc "Returns the total duration of notes.\n  e.g. (->> melody duration)"}, :name leipzig.melody/duration, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 15, :method-params ([notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 105, :end-line 105, :max-fixed-arity 1, :fn-var true, :arglists (quote ([notes])), :doc "Returns the total duration of notes.\n  e.g. (->> melody duration)"}, all {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 67, :column 7, :end-line 67, :end-column 10, :arglists (quote ([k v notes])), :doc "Sets a constant value for each note of a melody.\n  e.g. (->> notes (all :part :drum))"}, :name leipzig.melody/all, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 10, :method-params ([k v notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 67, :end-line 67, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k v notes])), :doc "Sets a constant value for each note of a melody.\n  e.g. (->> notes (all :part :drum))"}, utter {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 15, :column 7, :end-line 15, :end-column 12, :arglists (quote ([object time duration velocity]))}, :name leipzig.melody/utter, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 12, :method-params ([object time duration velocity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 15, :end-line 15, :max-fixed-arity 4, :fn-var true, :arglists (quote ([object time duration velocity]))}, before? {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 78, :column 8, :end-line 78, :end-column 15, :private true, :arglists (quote ([a b]))}, :private true, :name leipzig.melody/before?, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 15, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 78, :end-line 78, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, if-applicable {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 52, :column 8, :end-line 52, :end-column 21, :private true, :arglists (quote ([applies? f]))}, :private true, :name leipzig.melody/if-applicable, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 21, :method-params ([applies? f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 52, :end-line 52, :max-fixed-arity 2, :fn-var true, :arglists (quote ([applies? f]))}, accelerando {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 148, :column 7, :end-line 148, :end-column 18, :arglists (quote ([from to by])), :doc "Linearly interpolated change between from and to.\n  e.g. (->> notes (tempo (accelerando 0 4 3/2))))"}, :name leipzig.melody/accelerando, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 18, :method-params ([from to by]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 148, :end-line 148, :max-fixed-arity 3, :fn-var true, :arglists (quote ([from to by])), :doc "Linearly interpolated change between from and to.\n  e.g. (->> notes (tempo (accelerando 0 4 3/2))))"}, after {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 73, :column 7, :end-line 73, :end-column 12, :arglists (quote ([wait notes])), :doc "Delay notes by wait.\n  e.g. (->> melody (after 3))"}, :name leipzig.melody/after, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 12, :method-params ([wait notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 73, :end-line 73, :max-fixed-arity 2, :fn-var true, :arglists (quote ([wait notes])), :doc "Delay notes by wait.\n  e.g. (->> melody (after 3))"}, phrase {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 22, :column 7, :end-line 22, :end-column 13, :arglists (quote ([durations pitches velocities] [durations pitches])), :doc "Translates a sequence of durations and pitches into a melody.\n  nil pitches signify rests, vectors represent clusters, and maps\n  represent chords. Vector durations represent repeated notes.\n  e.g. (phrase [1/2 1/2 3/2 3/2] [0 1 nil 4])\n  (phrase [1 1 2] [4 3 [0 2]])\n  (phrase [1 [1 2]] [4 3])\n  (phrase (repeat 4) (map #(-> triad (root %))) [0 3 4 3])", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([durations pitches velocities] [durations pitches]), :arglists ([durations pitches velocities] [durations pitches]), :arglists-meta (nil nil)}}, :name leipzig.melody/phrase, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([durations pitches velocities] [durations pitches]), :arglists ([durations pitches velocities] [durations pitches]), :arglists-meta (nil nil)}, :method-params ([durations pitches velocities] [durations pitches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 22, :end-line 22, :max-fixed-arity 3, :fn-var true, :arglists ([durations pitches velocities] [durations pitches]), :doc "Translates a sequence of durations and pitches into a melody.\n  nil pitches signify rests, vectors represent clusters, and maps\n  represent chords. Vector durations represent repeated notes.\n  e.g. (phrase [1/2 1/2 3/2 3/2] [0 1 nil 4])\n  (phrase [1 1 2] [4 3 [0 2]])\n  (phrase [1 [1 2]] [4 3])\n  (phrase (repeat 4) (map #(-> triad (root %))) [0 3 4 3])"}, with {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 79, :column 7, :end-line 79, :end-column 11, :arglists (quote ([[a & other-as :as as] [b & other-bs :as bs]] [as bs & others])), :doc "Blends melodies.\n  e.g. (->> melody (with bass drums))", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([[a & other-as :as as] [b & other-bs :as bs]]), :arglists ([[a & other-as :as as] [b & other-bs :as bs]] [as bs & others]), :arglists-meta (nil nil)}}, :name leipzig.melody/with, :variadic true, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([[a & other-as :as as] [b & other-bs :as bs]]), :arglists ([[a & other-as :as as] [b & other-bs :as bs]] [as bs & others]), :arglists-meta (nil nil)}, :method-params ([[a & other-as :as as] [b & other-bs :as bs]]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 79, :end-line 79, :max-fixed-arity 2, :fn-var true, :arglists ([[a & other-as :as as] [b & other-bs :as bs]] [as bs & others]), :doc "Blends melodies.\n  e.g. (->> melody (with bass drums))"}, rhythm {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 41, :column 7, :end-line 41, :end-column 13, :arglists (quote ([durations])), :doc "Translates a sequence of durations into a rhythm.\n  e.g. (rhythm [1 1 2])"}, :name leipzig.melody/rhythm, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 13, :method-params ([durations]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 41, :end-line 41, :max-fixed-arity 1, :fn-var true, :arglists (quote ([durations])), :doc "Translates a sequence of durations into a rhythm.\n  e.g. (rhythm [1 1 2])"}, then {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 114, :column 7, :end-line 114, :end-column 11, :arglists (quote ([later earlier])), :doc "Sequences later after earlier.\n  e.g. (->> call (then response))"}, :name leipzig.melody/then, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 11, :method-params ([later earlier]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 114, :end-line 114, :max-fixed-arity 2, :fn-var true, :arglists (quote ([later earlier])), :doc "Sequences later after earlier.\n  e.g. (->> call (then response))"}, wherever {:protocol-inline nil, :meta {:file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :line 53, :column 7, :end-line 53, :end-column 15, :arglists (quote ([applies? k f notes])), :doc "Applies f to the k key of each note wherever condition? returns true.\n  e.g. (->> notes (wherever (comp not :part), :part (is :piano))"}, :name leipzig.melody/wherever, :variadic false, :file "/home/ben/.boot/cache/tmp/home/ben/src/rhapsody/l6b/15ekmk/demo/composition.out/leipzig/melody.cljc", :end-column 15, :method-params ([applies? k f notes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 53, :end-line 53, :max-fixed-arity 4, :fn-var true, :arglists (quote ([applies? k f notes])), :doc "Applies f to the k key of each note wherever condition? returns true.\n  e.g. (->> notes (wherever (comp not :part), :part (is :piano))"}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:time :pitch :duration :otherwise :velocity}, :order [:pitch :time :duration :velocity :otherwise]}, :doc nil}